= https://github.com/simonis/Memory[Linux Process Layout]
:toc:
:toc-placement!:
:source-highlighter: pygments
:icons: font
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:important-caption: :heavy_exclamation_mark:
:caution-caption: :fire:
:warning-caption: :warning:
endif::[]

This is a tiny writeup (mostly for me such that I don't forget about it :) how a simple, 64-bit Linux process is laid out in memory and how a processes memory consumption can be analyzed. A future article will then focus on the native memory layout and consumption of a Java process.

== Where it all begins.. (i.e. `execve()`)

Let's start our journey with the execution of the standard C-library function http://pubs.opengroup.org/onlinepubs/9699919799/functions/exec.html[`execve()`] which in turn executes the https://elixir.bootlin.com/linux/v4.18.5/source/fs/exec.c#L1963[`execve`] system call. `execve` is usually called right after `fork()` and replaces (i.e. overlays) the old programs stack, heap and data segments with the ones of the new program (http://man7.org/linux/man-pages/man2/execve.2.html[see the man page of `execve(2)`]).
